/*
*
* 题目描述：
*      每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。
*  HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让
*  小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每
*  次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再
*  回到圈中,从他的下一个小朋友开始,继续0...m-1报数....这样下去....直到剩下最
*  后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦)。
*  请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)
*
* */


public class Test {
    /*
    * 算法思路：
    *    首先，我们定义一个关于n和m的方程f(n,m)，表示每次在n个数字(0~n-1)中
    * 删除第m个数字后，最终剩下的数字。
    *    很明显，第一次删除的数字是(m-1)%n。方便起见，我们把第一个删除的数字
    * 记为k，那么删除k之后的下一次计数，将会在k+1,k+2,…,n-1,0,…,k-1，即删除
    * 完且计数起点变为删除数字的后一个。
    *    接下来，是在剩余n-1个数中删除第m个，由于计数序列发生了改变，因此函数
    * 需要记为f'(n-1,m)。显然，f(n,m)=f'(n-1,m)。
    *    剩下的问题也是最关键的问题，就是k+1,k+2,…,n-1,0,…,k-1的序列如何映射
    * 为0~n-2的序列，从而将问题简化为第一步的过程：
    *    k+1 ——> 0
    *    k+2 ——> 1
    *    ……
    *    n-1 ——> n-k-2
    *    0   ——> n-k-1
    *    1   ——> n-k
    *    ……
    *    k-1 ——> n-2
    *    综上，我们定义p为数字序列k+1,k+2,…,n-1,0,…,k-1到新序列0~n-2的映射，
    * 则p(x)=(x-k-1)%n，其中x为映射前的数字，p(x)为x在新序列中的数字。该映射
    * 的逆映射是q(y)=(y+k+1)%n。
    *    因此，f(n,m)=f'(n-1,m)=q[f(n-1,m)]=[f(n-1,m)+k+1]%n，其中
    * k=(m-1)%n已知，所以f'(n-1,m)=[f(n-1,m)+(m-1)%n+1]%n=[f(n-1,m)+m]%n。
    *
    *    综上所述，最终得到了一个递归公式。要得到n个数序列中剩下的数字，只需要
    * 得到n-1个数字序列中最后剩下的数字，并以此类推。当n=1是，也就是序列只有一个
    * 数字(下标为0)时，就找到了最终一个数。
    *  */
    public static int LastRemaining_Solution(int n, int m) {
        if(n <= 0 || m <= 0)
            return -1;
        if(n == 1)
            return 0;
        return (LastRemaining_Solution(n-1,m)+m)%n;
    }


    public static void main(String args[]){
        System.out.println(LastRemaining_Solution(5,3));
    }
}
