/*
*
* 题目描述：
*     给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，
* 那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个：
* {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}，
* {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。
*
* */

import java.util.ArrayDeque;
import java.util.ArrayList;

public class Test {
    /*
    * 算法思路：
    *     滑动窗口显然是一个队列，因为右侧数字不断进队列，左侧数字不断出队列；
    * 同时，考虑到队列内为了提出较小的数字，需要从队列尾部删除元素，又是一个栈。
    * 因此使用一个双端队列。
    *     问题解决的过程可以归纳为：(队列第一个位置保存当前窗口的最大值)
    * 1. 窗口从下标为-2的位置从左向右滑动，接收到第一个新的元素(下标为0)，入双端队列，并不做变动；
    * 2. 窗口继续向右滑动，窗口起始位置为-1终止为2，此时接收到一个新的元素。
    * 此时需要比较新元素(下标为1)与队列中第一个元素的大小，若大于第一个，则首元素出队列，
    * 新元素入队列。若小于，则入队列。其他不变动。
    * 3. 窗口继续向右滑动，窗口起始位置为-1终止为1，此时接收到一个新的元素。
    * 此时仍需要比较新元素(下标为2)与队列中第每个元素的大小，为方便操作，我们从队列中最后一个元素开始，
    * 不断向前比较。若新元素大于队列中的元素，则队列出栈操作(因为此后，该元素的下标比新元素小，同时数值
    * 也比新元素小，因此永远不会成为窗口中的最大值了)。比较完毕后，新元素入队列。
    * 4. 窗口继续向右滑动，窗口起始位置为0终止为2，此时接收到一个新的元素。此时与步骤3类似。
    * # 在此之前的各步，由于窗口始终没有填满，且不存在队列中的元素已经被划过
    * 5. 窗口继续向右滑动，窗口起始位置为1终止为3，此时接收到一个新的元素。
    * 这时，由于窗口已经滑动并且将下标为0的元素错过，而0可能是当前队列中的队首元素(最大值)，
    * 这种情况就不能将它作为最大值输出了，因此该步还需要判断当前的队首元素下标是否已经错过，
    * 之后，仍旧是从队列末尾至前的比较与出栈入栈。
    * 后面的情况类似，不在详述……
    *
    *     现在问题是，如何判断双端队列的队首元素，不在当前滑动窗口内了？
    * 其实，我们可以再双端队列中，存储对应数字的下标值，而非数值。
    * 这样，当接收到新元素，直接换位接收到新下标i。而窗口的起始下标，可以通过
    * begin=i-size+1计算，其中size是窗口的大小，begin是窗口的起始下标。
    *
    *  */

    public static ArrayList<Integer> maxInWindows(int [] num, int size) {
        ArrayList<Integer> ret = new ArrayList<>();

        // 异常输入
        if(num == null || num.length == 0 || size <= 0)
            return ret;

        // 计算当前窗口的开始位置
        int begin = -2;
        // 存放下标的双端队列，队首为窗口中最大元素的下标
        ArrayDeque<Integer> q = new ArrayDeque<>();
        // i作为当前进入到窗口中的新元素，也是窗口的终止位置
        for(int i=0; i<num.length; i++){
            // 计算窗口的起始位置
            begin = i - size + 1;
            // 当前队列空时，直接添加下标i进入队列
            if(!q.isEmpty()){
                // 若窗口起始位置大于i，表示队列首下标已经被划出，出队列
                if(begin > q.getFirst())
                    q.removeFirst();
                // 否则从队尾不断查看元素并与新下标i对应的数值num[i]进行比较
                // 队列中比num[i]的元素通通出栈
                // 防止栈空
                while(!q.isEmpty() && num[q.peekLast()] < num[i])
                    q.removeLast();
            }
            // 比较完毕，新元素下标入队列
            q.offerLast(i);
            // 窗口内已经填充满元素，此时需要输出一个最大值(队列首元素下标对应的数值)
            if(begin >= 0)
                ret.add(num[q.peekFirst()]);
        }
        // 返回相关数组
        return ret;
    }

    public static void main(String args[]) {
        int a[] = {2,3,4,2,6,2,5,1};
        ArrayList<Integer> res = maxInWindows(a,3);
        for(Integer i : res)
            System.out.print(i + " ");
    }
}
